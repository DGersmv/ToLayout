<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Landscape Helper</title>

  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #efefef;
      margin: 0;
      color: #2f2f2f;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 12px 0;
    }
    .palette {
      width: 340px;
      background: #efefef;
      border: 1px solid #a6a3a0;
      box-shadow: inset 0 0 0 1px #f8f8f8;
      padding: 12px;
      box-sizing: border-box;
      font-size: 12px;
      line-height: 1.35;
    }
    h1 {
      font-size: 13px;
      font-weight: 600;
      margin: 0 0 10px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    .section {
      margin-bottom: 12px;
    }
    .section-title {
      font-weight: 600;
      margin-bottom: 6px;
      text-transform: uppercase;
      font-size: 11px;
      color: #54524f;
    }
    .divider {
      height: 1px;
      background: #c7c3bd;
      margin: 10px 0;
    }
    .selection-table-container {
      background: transparent;
    }
    table.selection-table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      font-size: 11px;
      box-shadow: inset 0 0 0 1px #d2cec9;
    }
    table.selection-table thead th {
      text-align: left;
      background: #dcd9d4;
      border: 1px solid #b6b2ae;
      padding: 4px 6px;
      font-weight: 600;
    }
    table.selection-table tbody td {
      border: 1px solid #c8c4c0;
      padding: 4px 6px;
    }
    table.selection-table tbody tr:hover td {
      background: #f3f1ee;
    }
    table.selection-table th:first-child,
    table.selection-table td:first-child {
      width: 32px;
      text-align: center;
    }
    table.selection-table thead,
    table.selection-table tbody {
      display: block;
    }
    table.selection-table thead tr,
    table.selection-table tbody tr {
      display: table;
      width: 100%;
      table-layout: fixed;
    }
    table.selection-table tbody {
      max-height: 160px;
      overflow-y: auto;
      overflow-x: hidden;
      border-left: 1px solid #c8c4c0;
      border-right: 1px solid #c8c4c0;
      border-bottom: 1px solid #c8c4c0;
    }
    table.selection-table td.count-cell {
      cursor: pointer;
    }
    .button-flat {
      display: inline-block;
      padding: 4px 10px;
      border: 1px solid #a8a5a2;
      border-radius: 2px;
      background: #dcd9d4;
      color: #2f2f2f;
      font-size: 12px;
      cursor: pointer;
      box-shadow: inset 0 1px 0 #f5f4f2;
      min-width: 70px;
      text-align: center;
    }
    .button-flat:hover {
      background: #e7e4de;
    }
    .button-flat:active {
      background: #cac7c2;
    }
    .button-flat:disabled {
      background: #e2e0de;
      color: #8a8a8a;
      cursor: default;
    }
    .button-primary {
      font-weight: 600;
    }
    .button-full {
      width: 100%;
    }
    .controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }
    .info-box {
      margin-top: 8px;
      padding: 6px;
      border: 1px solid #c0beb9;
      background: #f9f8f6;
      min-height: 32px;
      font-size: 11px;
      white-space: pre-wrap;
    }
    .launcher-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .link-minor {
      display: block;
      margin-top: 12px;
      text-align: center;
      color: #2f2f2f;
      text-decoration: none;
      font-size: 11px;
    }
    .link-minor:hover {
      text-decoration: underline;
    }
    input[type="number"],
    input[type="text"],
    select {
      width: 100%;
      padding: 4px;
      border: 1px solid #ada9a4;
      border-radius: 2px;
      background: #ffffff;
      box-sizing: border-box;
      font-size: 12px;
    }
    input[type="checkbox"] {
      margin-right: 4px;
    }
    .help-button {
      font-size: 11px;
      padding: 4px 8px;
      min-width: auto;
    }
    #selection-ok-btn {
      margin-left: auto;
    }
    .log-box {
      padding: 6px;
      border: 1px solid #c0beb9;
      background: #ffffff;
      height: 70px;
      overflow: auto;
      font-family: Consolas, monospace;
      font-size: 11px;
      color: #353535;
    }
  </style>

  <script type="text/javascript">
    "use strict";

    // ================= helpers =================
    let logBuffer = ''; // –ë—É—Ñ–µ—Ä –¥–ª—è –ª–æ–≥–æ–≤ (—Å–∫–æ—Ä–æ—Å—Ç—å!)
    
    function AddLog(msg) {
      // Log to console
      try { console.log(String(msg)); } catch(_) {}
      
      // Also log to UI
      const box = document.getElementById('log-box');
      if (!box) return;
      
      const now = new Date().toLocaleTimeString();
      logBuffer += "\n[" + now + "] " + msg;
      
      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –±—É—Ñ–µ—Ä (–º–∞–∫—Å 5000 —Å–∏–º–≤–æ–ª–æ–≤)
      if (logBuffer.length > 5000) {
        logBuffer = logBuffer.substring(logBuffer.length - 4000);
      }
      
      // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–¥–Ω–∏–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
      box.textContent = logBuffer;
      box.scrollTop = box.scrollHeight;
    }
    
    function setInfo(id, msg) {
      const el = document.getElementById(id);
      if (el) el.textContent = msg;
    }
    function parseNumber(inputEl, def = 0) {
      let v = (typeof inputEl.valueAsNumber === 'number' && !isNaN(inputEl.valueAsNumber)) ? inputEl.valueAsNumber : NaN;
      if (isNaN(v)) {
        const p = parseFloat(String(inputEl.value || "").replace(',', '.'));
        v = Number.isFinite(p) ? p : def;
      }
      return v;
    }

    // Global variable for storing the last applied markup step
    let g_lastMarkupStepMm = 2500; // Default value

    // =============== ACAPI bridge waiting (with diagnostics) ===============
    function whenACAPIReadyDo(cb) {
      let fired = false;
      const probe = () => {
        const A = window.ACAPI;
        if (!A) return null;
        return {
          hasSelect : typeof A.GetSelectedElements === 'function',
          hasGround : typeof A.ApplyGroundOffset  === 'function',
          hasNewDlt : typeof A.SetZDelta         === 'function' && typeof A.ApplyZDelta === 'function',
          hasOldDlt : typeof A.ApplyZDelta       === 'function' && A.ApplyZDelta.length >= 1
        };
      };
      const ready = () => {
        const caps = probe();
        return caps && (caps.hasSelect || caps.hasGround || caps.hasNewDlt || caps.hasOldDlt);
      };
      const fire = () => {
        if (fired) return;
        fired = true;
        try {
          const caps = probe();
          AddLog(`[UI] ACAPI ready: select=${!!caps.hasSelect} ground=${!!caps.hasGround} newŒî=${!!caps.hasNewDlt} oldŒî=${!!caps.hasOldDlt}`);
          cb();
        } catch (e) { AddLog('[UI] callback error: ' + e); }
      };

      if (ready()) { fire(); return; }

      let tries = 0;
      const maxTries = 120;
      const iv = setInterval(() => {
        if (ready()) {
          clearInterval(iv);
          fire();
        } else if (++tries > maxTries) {
          clearInterval(iv);
          AddLog('[UI] ACAPI never appeared (check palette/plugin loading)');
        }
      }, 50);
    }

    // =============== selection table ===============
    // –ú–æ–¥–µ–ª—å –¥–∞–Ω–Ω—ã—Ö: groupKey -> Array<GUID>
    let groupDataMap = {}; // groupKey -> { guids: Array<GUID>, type, id, layer, count }
    let selectedGuids = new Set(); // Set<GUID> - –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ GUID

    function UpdateSelectedElements() {
      const A = window.ACAPI;
      if (!A || typeof A.GetSelectedElements !== 'function') {
        // AddLog('[UI] ACAPI.GetSelectedElements unavailable');
        return;
      }
      A.GetSelectedElements().then(function (elemInfos) {
        const selectionTable = document.getElementById('selection');
        
        // –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É groupKey -> Array<GUID>
        groupDataMap = {};
        if (elemInfos && elemInfos.length > 0) {
          for (let i = 0; i < elemInfos.length; i++) {
            const guidStr   = elemInfos[i][0];
            const typeName  = elemInfos[i][1];
            const elemID    = elemInfos[i][2];
            const layerName = elemInfos[i][3] || 'Unknown';
            
            const groupKey = typeName + "||" + elemID + "||" + layerName;
            if (!groupDataMap[groupKey]) {
              groupDataMap[groupKey] = {
                guids: [],
                type: typeName,
                id: elemID,
                layer: layerName,
                count: 0
              };
            }
            groupDataMap[groupKey].guids.push(guidStr);
            groupDataMap[groupKey].count++;
          }
        }
        
        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: —Ñ–æ—Ä–º–∏—Ä—É–µ–º –≤–µ—Å—å HTML –∑–∞ —Ä–∞–∑
        let html = '';
        if (Object.keys(groupDataMap).length === 0) {
          html = '<tr><td colspan="5">–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤</td></tr>';
        } else {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —á–µ–∫–±–æ–∫—Å–æ–≤ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è selectedGuids
          // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —á–µ–∫–±–æ–∫—Å–æ–≤ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–æ–π
          const checkedGroups = new Set();
          const checkboxes = selectionTable.querySelectorAll('input[type="checkbox"][data-group]');
          checkboxes.forEach(cb => {
            if (cb.checked) {
              checkedGroups.add(cb.getAttribute('data-group'));
            }
          });
          
          // –ï—Å–ª–∏ selectedGuids –ø—É—Å—Ç –∏ –Ω–µ—Ç –æ—Ç–º–µ—á–µ–Ω–Ω—ã—Ö —á–µ–∫–±–æ–∫—Å–æ–≤ - —ç—Ç–æ –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫, –æ—Ç–º–µ—á–∞–µ–º –≤—Å–µ
          const isFirstRun = selectedGuids.size === 0 && checkedGroups.size === 0;
          
          if (isFirstRun) {
            // –ü—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ –≤—Å–µ –≥—Ä—É–ø–ø—ã –æ—Ç–º–µ—á–µ–Ω—ã (–≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —É–∂–µ –≤—ã–¥–µ–ª–µ–Ω—ã –≤ Archicad)
            Object.keys(groupDataMap).forEach(groupKey => {
              const group = groupDataMap[groupKey];
              group.guids.forEach(guid => selectedGuids.add(guid));
            });
          } else {
            // –û–±–Ω–æ–≤–ª—è–µ–º selectedGuids –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ—Ç–º–µ—á–µ–Ω–Ω—ã—Ö –≥—Ä—É–ø–ø
            selectedGuids.clear();
            checkedGroups.forEach(groupKey => {
              if (groupDataMap[groupKey]) {
                groupDataMap[groupKey].guids.forEach(guid => selectedGuids.add(guid));
              }
            });
          }
          
          // –§–æ—Ä–º–∏—Ä—É–µ–º HTML —Å—Ç—Ä–æ–∫
          for (const groupKey of Object.keys(groupDataMap)) {
            const group = groupDataMap[groupKey];
            const isChecked = group.guids.every(guid => selectedGuids.has(guid));
            html += '<tr data-group="' + escapeHtml(groupKey) + '">' +
              '<td><input type="checkbox" data-group="' + escapeHtml(groupKey) + '" ' + (isChecked ? 'checked' : '') + ' onchange="handleRowCheckboxChange(this)"></td>' +
              '<td>' + escapeHtml(group.type) + '</td>' +
              '<td>' + escapeHtml(group.id) + '</td>' +
              '<td>' + escapeHtml(group.layer) + '</td>' +
              '<td class="count-cell" onclick="toggleRowCheckbox(\'' + escapeHtml(groupKey) + '\')">' + group.count + '</td>' +
              '</tr>';
          }
        }
        
        // –û–¥–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è DOM –≤–º–µ—Å—Ç–æ –º–Ω–æ–∂–µ—Å—Ç–≤–∞
        selectionTable.innerHTML = html;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —á–µ–∫–±–æ–∫—Å–∞ "–≤—ã–±—Ä–∞—Ç—å –≤—Å—ë"
        updateSelectAllCheckbox();
      }).catch(err => console.log('[UI] GetSelectedElements error: ' + err));
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function toggleRowCheckbox(groupKey) {
      const checkbox = document.querySelector('input[type="checkbox"][data-group="' + escapeHtml(groupKey) + '"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        handleRowCheckboxChange(checkbox);
      }
    }

    function handleRowCheckboxChange(checkbox) {
      const groupKey = checkbox.getAttribute('data-group');
      if (!groupKey || !groupDataMap[groupKey]) return;
      
      const group = groupDataMap[groupKey];
      if (checkbox.checked) {
        // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ GUID —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã
        group.guids.forEach(guid => selectedGuids.add(guid));
      } else {
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ GUID —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã
        group.guids.forEach(guid => selectedGuids.delete(guid));
      }
      
      updateSelectAllCheckbox();
    }

    function updateSelectAllCheckbox() {
      const selectAllCheckbox = document.getElementById('select-all-checkbox');
      if (!selectAllCheckbox) return;
      
      const visibleGroups = Object.keys(groupDataMap);
      if (visibleGroups.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
        return;
      }
      
      let checkedCount = 0;
      visibleGroups.forEach(groupKey => {
        const group = groupDataMap[groupKey];
        if (group.guids.every(guid => selectedGuids.has(guid))) {
          checkedCount++;
        }
      });
      
      if (checkedCount === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
      } else if (checkedCount === visibleGroups.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
      } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
      }
    }

    function handleSelectAllCheckboxChange() {
      const selectAllCheckbox = document.getElementById('select-all-checkbox');
      if (!selectAllCheckbox) return;
      
      const visibleGroups = Object.keys(groupDataMap);
      const isChecked = selectAllCheckbox.checked;
      
      visibleGroups.forEach(groupKey => {
        const group = groupDataMap[groupKey];
        const checkbox = document.querySelector('input[type="checkbox"][data-group="' + escapeHtml(groupKey) + '"]');
        
        if (isChecked) {
          // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ GUID –≤—Å–µ—Ö –≥—Ä—É–ø–ø
          group.guids.forEach(guid => selectedGuids.add(guid));
          if (checkbox) checkbox.checked = true;
        } else {
          // –£–¥–∞–ª—è–µ–º –≤—Å–µ GUID –≤—Å–µ—Ö –≥—Ä—É–ø–ø
          group.guids.forEach(guid => selectedGuids.delete(guid));
          if (checkbox) checkbox.checked = false;
        }
      });
      
      selectAllCheckbox.indeterminate = false;
    }

    function applyCheckedSelection() {
      const A = window.ACAPI;
      if (!A || typeof A.ApplyCheckedSelection !== 'function') {
        AddLog('[UI] ACAPI.ApplyCheckedSelection –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞');
        return;
      }
      
      const guidsArray = Array.from(selectedGuids);
      if (guidsArray.length === 0) {
        AddLog('[UI] –ù–µ –≤—ã–±—Ä–∞–Ω–æ –Ω–∏ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã');
        return;
      }
      
      AddLog('[UI] –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è –¥–ª—è ' + guidsArray.length + ' —ç–ª–µ–º–µ–Ω—Ç–æ–≤');
      
      A.ApplyCheckedSelection(guidsArray).then(function(result) {
        if (result && typeof result === 'object') {
          const applied = result.applied || 0;
          const requested = result.requested || guidsArray.length;
          AddLog('[UI] –í—ã–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ: ' + applied + ' –∏–∑ ' + requested + ' —ç–ª–µ–º–µ–Ω—Ç–æ–≤');
          setInfo("selection-info", "–í—ã–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ: " + applied + " –∏–∑ " + requested + " —ç–ª–µ–º–µ–Ω—Ç–æ–≤");
          
          // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–±–ª–∏—Ü—É –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è
          setTimeout(UpdateSelectedElements, 500);
        } else {
          AddLog('[UI] –í—ã–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ');
          setTimeout(UpdateSelectedElements, 500);
        }
      }).catch(function(err) {
        AddLog('[UI] –û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤—ã–¥–µ–ª–µ–Ω–∏—è: ' + err);
        setInfo("selection-info", "–û—à–∏–±–∫–∞: " + err);
      });
    }

    // =============== ID renaming (bulk, without layers) ===============
    function changeAllSelectedIDs() {
      const A = window.ACAPI;
      if (!A || typeof A.ChangeSelectedElementsID !== 'function') {
        AddLog('[UI] ACAPI.ChangeSelectedElementsID unavailable');
        return;
      }
      
      const baseID = document.getElementById('baseID').value.trim();
      if (!baseID) {
        AddLog('[UI] Enter base name for element IDs');
        document.getElementById('baseID').focus();
        return;
      }
      
      AddLog('[UI] Changing element IDs with base name: ' + baseID);
      
      A.ChangeSelectedElementsID(baseID).then(function(success) {
        if (success) {
          AddLog('[UI] All selected element IDs successfully changed!');
          setInfo("id-change-info", "ID –æ–±–Ω–æ–≤–ª–µ–Ω—ã. –ù–∞–ø—Ä–∏–º–µ—Ä: " + baseID + "-01, " + baseID + "-02, " + baseID + "-03...");
          document.getElementById('baseID').value = '';
          setTimeout(UpdateSelectedElements, 1000);
        } else {
          AddLog('[UI] Error changing element IDs');
          setInfo("id-change-info", "–û—à–∏–±–∫–∞! –í–æ–∑–º–æ–∂–Ω–æ, –Ω–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–ª–∏ —ç–ª–µ–º–µ–Ω—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–µ ID");
        }
      }).catch(function(err) {
        AddLog('[UI] Error calling ChangeSelectedElementsID: ' + err);
        setInfo("id-change-info", "–û—à–∏–±–∫–∞: " + err);
      });
    }

    // –•—Ä–∞–Ω–∏–º –ø–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
    let allLayersData = [];
    let expandedLayerFolders = new Set();
    let currentLayersFilter = '';
    
    // –£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å "–°–ª–æ–∏/" –∏–ª–∏ "Layers/" –∏–∑ –ø—É—Ç–∏
    function removeRootFolderPrefix(path) {
      if (!path || path === '') return '';
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ª–∏ –ø—É—Ç—å —Å "–°–ª–æ–∏/" –∏–ª–∏ "Layers/"
      if (path.startsWith('–°–ª–æ–∏/')) {
        return path.substring('–°–ª–æ–∏/'.length);
      }
      if (path.startsWith('Layers/')) {
        return path.substring('Layers/'.length);
      }
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–µ–∑ —Å–ª—ç—à–∞ –≤ –∫–æ–Ω—Ü–µ
      if (path === '–°–ª–æ–∏' || path === 'Layers') {
        return '';
      }
      return path;
    }
    
    // =============== folder/layer list loading ===============
    function loadExistingLayersList(filterText = '') {
      const A = window.ACAPI;
      const listEl = document.getElementById('existingLayersList');
      if (!listEl) return;

      listEl.innerHTML = '<option value="">–ó–∞–≥—Ä—É–∑–∫–∞...</option>';

      if (!A) {
        listEl.innerHTML = '<option value="">ACAPI –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</option>';
        return;
      }

      // –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Å–ª–æ–µ–≤ –µ—Å—Ç—å, –≤—ã–∑—ã–≤–∞–µ–º –µ—ë
      if (typeof A.GetLayersList === 'function') {
        A.GetLayersList().then(function(layersData) {
          if (!layersData || layersData.length === 0) {
            listEl.innerHTML = '<option value="">–°–ª–æ–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</option>';
            allLayersData = [];
            return;
          }

          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
          allLayersData = [];
          expandedLayerFolders = new Set();
          
          // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –º–∞—Å—Å–∏–≤ –º–∞—Å—Å–∏–≤–æ–≤ –≤ –º–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤
          for (let i = 0; i < layersData.length; i++) {
            const item = layersData[i];
            if (Array.isArray(item) && item.length >= 2) {
              const rawFolder = item[1] || '';
              allLayersData.push({
                name: item[0] || '',
                folder: removeRootFolderPrefix(rawFolder)
              });
            }
          }

          // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é
          filterLayersList(filterText);
        }).catch(function(err) {
          AddLog('[UI] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø–∏—Å–∫–∞ —Å–ª–æ–µ–≤: ' + err);
          listEl.innerHTML = '<option value="">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ª–æ–µ–≤</option>';
          allLayersData = [];
        });
      } else {
        // –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞, –æ—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–≥–ª—É—à–∫—É
        listEl.innerHTML = '<option value="">–§—É–Ω–∫—Ü–∏—è GetLayersList –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞</option>';
        AddLog('[UI] –§—É–Ω–∫—Ü–∏—è GetLayersList –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞');
        allLayersData = [];
        expandedLayerFolders = new Set();
      }
    }

    function filterLayersList(filterText = '') {
      const listEl = document.getElementById('existingLayersList');
      if (!listEl) return;

      currentLayersFilter = filterText || '';
      listEl.innerHTML = '';
      
      if (!allLayersData.length) {
        listEl.innerHTML = '<option value="">–°–ª–æ–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</option>';
        return;
      }

      const filter = currentLayersFilter.trim().toLowerCase();
      const isFiltering = filter.length > 0;
      const foldersTree = {};
      const rootLayers = [];

      allLayersData.forEach(item => {
        const layerName = item.name || '';
        const folderPath = item.folder || '';
        const fullPath = (folderPath ? folderPath + '/' : '') + layerName;

        if (!layerName) {
          return;
        }

        if (
          filter &&
          !fullPath.toLowerCase().includes(filter) &&
          !folderPath.toLowerCase().includes(filter)
        ) {
          return;
        }

        if (!folderPath) {
          rootLayers.push({
            name: layerName,
            fullPath
          });
          return;
        }

        const pathParts = folderPath.split('/').filter(Boolean);
        let node = foldersTree;

        for (let i = 0; i < pathParts.length; i++) {
          const part = pathParts[i];

          if (!node[part]) {
            node[part] = { _layers: [], _children: {} };
          }

          if (i === pathParts.length - 1) {
            node[part]._layers.push({
              name: layerName,
              fullPath,
              folderPath
            });
          } else {
            node = node[part]._children;
          }
        }
      });

      const indentUnit = '\u00A0\u00A0';

      const addFoldersToSelect = (tree, parentPath = '', depth = 0) => {
        const folderNames = Object.keys(tree).sort((a, b) => a.localeCompare(b));

        folderNames.forEach(folderName => {
          const folderNode = tree[folderName];
          const currentPath = parentPath ? parentPath + '/' + folderName : folderName;
          const hasSubfolders =
            folderNode._children && Object.keys(folderNode._children).length > 0;
          const hasLayers = folderNode._layers && folderNode._layers.length > 0;
          const hasChildren = hasSubfolders || hasLayers;
          const isExpanded = isFiltering || expandedLayerFolders.has(currentPath);

          const folderOpt = document.createElement('option');
          folderOpt.value = currentPath;
          folderOpt.dataset.type = 'folder';
          folderOpt.dataset.folder = currentPath;
          folderOpt.dataset.layer = '';
          folderOpt.dataset.expanded = isExpanded ? '1' : '0';
          const indicator = hasChildren ? (isExpanded ? '‚ñæ ' : '‚ñ∏ ') : '  ';
          folderOpt.textContent =
            indentUnit.repeat(depth) + indicator + 'üìÅ ' + folderName;
          listEl.appendChild(folderOpt);

          if (hasSubfolders && isExpanded) {
            addFoldersToSelect(folderNode._children, currentPath, depth + 1);
          }

          if (hasLayers && isExpanded) {
            folderNode._layers
              .slice()
              .sort((a, b) => a.name.localeCompare(b.name))
              .forEach(layer => {
                const layerOpt = document.createElement('option');
                layerOpt.value = layer.fullPath;
                layerOpt.dataset.type = 'layer';
                layerOpt.dataset.folder = layer.folderPath;
                layerOpt.dataset.layer = layer.name;
                layerOpt.textContent =
                  indentUnit.repeat(depth + 1) + 'üìÑ ' + layer.name;
                listEl.appendChild(layerOpt);
              });
          }
        });
      };

      addFoldersToSelect(foldersTree);

      if (rootLayers.length) {
        rootLayers.sort((a, b) => a.name.localeCompare(b.name));
        rootLayers.forEach(layer => {
          const opt = document.createElement('option');
          opt.value = layer.fullPath;
          opt.textContent = 'üìÑ ' + layer.name;
          opt.dataset.type = 'layer';
          opt.dataset.folder = '';
          opt.dataset.layer = layer.name;
          listEl.appendChild(opt);
        });
      }

      if (listEl.options.length === 0) {
        listEl.innerHTML = '<option value="">–ù–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö —Å–ª–æ–µ–≤</option>';
      }
    }

    function selectFromList() {
      const listEl = document.getElementById('existingLayersList');
      if (!listEl || listEl.selectedIndex < 0) return;

      const selectedOption = listEl.options[listEl.selectedIndex];
      if (!selectedOption) return;

      const optionType = selectedOption.dataset.type || 'layer';
      
      if (optionType === 'folder') {
        const folderPath = selectedOption.dataset.folder || selectedOption.value;
        document.getElementById('layerFolder').value = folderPath;
        document.getElementById('layerName').value = '';
        AddLog('[UI] –í—ã–±—Ä–∞–Ω–∞ –ø–∞–ø–∫–∞: ' + folderPath);
      } else {
        const folderPath = selectedOption.dataset.folder || '';
        const layerName = selectedOption.dataset.layer || selectedOption.value;
        document.getElementById('layerFolder').value = folderPath;
        document.getElementById('layerName').value = layerName;
        AddLog('[UI] –í—ã–±—Ä–∞–Ω —Å–ª–æ–π: ' + (folderPath ? folderPath + ' / ' : '') + layerName);
      }
    }

    function handleLayersListDoubleClick() {
      const listEl = document.getElementById('existingLayersList');
      if (!listEl || listEl.selectedIndex < 0) return;

      const selectedOption = listEl.options[listEl.selectedIndex];
      if (!selectedOption) return;

      const optionType = selectedOption.dataset.type || 'layer';

      if (optionType === 'folder') {
        const folderPath = selectedOption.dataset.folder || selectedOption.value || '';
        if (expandedLayerFolders.has(folderPath)) {
          expandedLayerFolders.delete(folderPath);
          AddLog('[UI] –°–≤–µ—Ä–Ω—É–ª–∏ –ø–∞–ø–∫—É: ' + folderPath);
        } else {
          expandedLayerFolders.add(folderPath);
          AddLog('[UI] –†–∞–∑–≤–µ—Ä–Ω—É–ª–∏ –ø–∞–ø–∫—É: ' + folderPath);
        }

        filterLayersList(currentLayersFilter);

        const updatedList = document.getElementById('existingLayersList');
        if (updatedList) {
          for (let i = 0; i < updatedList.options.length; i++) {
            const opt = updatedList.options[i];
            if (
              opt.dataset.type === 'folder' &&
              (opt.dataset.folder || opt.value) === folderPath
            ) {
              updatedList.selectedIndex = i;
              break;
            }
          }
        }
      } else {
        selectFromList();
      }
    }

    // =============== folder/layer creation + move ===============
    function createLayerAndMoveElements() {
      const A = window.ACAPI;
      if (!A) {
        AddLog('[UI] ACAPI unavailable');
        return;
      }

      let folderPath = document.getElementById('layerFolder').value.trim();
      const layerName  = document.getElementById('layerName').value.trim();
      const hideLayer = document.getElementById('hideLayer').checked;

      // –£–¥–∞–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å "–°–ª–æ–∏/" –∏–ª–∏ "Layers/" –∏–∑ –ø—É—Ç–∏ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
      folderPath = removeRootFolderPrefix(folderPath);

      if (!folderPath && !layerName) {
        AddLog('[UI] –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ –∏–ª–∏ –∏–º—è —Å–ª–æ—è');
        document.getElementById('layerFolder').focus();
        return;
      }
      if (!layerName) {
        AddLog('[UI] –í–≤–µ–¥–∏—Ç–µ –∏–º—è —Å–ª–æ—è');
        document.getElementById('layerName').focus();
        return;
      }

      AddLog('[UI] –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏: ' + folderPath + ', —Å–ª–æ–π: ' + layerName + ', —Å–∫—Ä—ã—Ç—å: ' + hideLayer);
      setInfo("info-layers", "–°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏, —Å–ª–æ—è –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤...");

      if (typeof A.CreateLayerAndMoveElements === 'function') {
        const params = folderPath + '|' + layerName + '|' + (hideLayer ? '1' : '0');

        AddLog('[JS] CreateLayerAndMoveElements');
        AddLog('[JS] Parameters: ' + params);
        
        A.CreateLayerAndMoveElements(params).then(function(success) {
          AddLog('[JS] CreateLayerAndMoveElements returned: ' + success);
          if (success) {
            AddLog('[UI] –ü–∞–ø–∫–∞/—Å–ª–æ–π —Å–æ–∑–¥–∞–Ω—ã, —ç–ª–µ–º–µ–Ω—Ç—ã –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã');
            setInfo("info-layers", "–£—Å–ø–µ—à–Ω–æ. –ü–∞–ø–∫–∞: " + folderPath + ", —Å–ª–æ–π: " + layerName);
            
            // –û—á–∏—â–∞–µ–º –ø–æ–ª—è –≤–≤–æ–¥–∞
            document.getElementById('layerFolder').value  = '';
            document.getElementById('layerName').value    = '';
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Å–ª–æ–µ–≤ –ø–æ—Å–ª–µ –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏ (—á—Ç–æ–±—ã ArchiCAD —É—Å–ø–µ–ª –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É)
            setTimeout(function() {
              loadExistingLayersList(''); // –ó–∞–≥—Ä—É–∂–∞–µ–º –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Å–ª–æ–∏ –∏ –ø–∞–ø–∫–∏
            }, 500);
            
            setTimeout(UpdateSelectedElements, 1000);
          } else {
            AddLog('[UI] –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏/—Å–ª–æ—è –∏–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤');
            setInfo("info-layers", "–û—à–∏–±–∫–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–≤–µ–¥–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ —Ç–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä.");
          }
        }).catch(function(err) {
          AddLog('[UI] –û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞ CreateLayerAndMoveElements: ' + err);
          setInfo("info-layers", "–û—à–∏–±–∫–∞: " + err);
        });
      } else {
        AddLog('[UI] –§—É–Ω–∫—Ü–∏—è CreateLayerAndMoveElements –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞');
        setInfo("info-layers", "–§—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ (–æ–±–Ω–æ–≤–∏—Ç–µ –ø–ª–∞–≥–∏–Ω)");
      }
    }

    // =============== orientation/distribution/... ===============
    function SetDistributionLine()     { if (ACAPI?.SetDistributionLine)     ACAPI.SetDistributionLine();     setInfo("info-dist","–õ–∏–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞"); }
    function SetDistributionObject()   { if (ACAPI?.SetDistributionObject)   ACAPI.SetDistributionObject();   setInfo("info-dist","–û–±—ä–µ–∫—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"); }
    function openDistributionPalette() {
      if (ACAPI?.OpenDistributionPalette) {
        AddLog('[UI] OpenDistributionPalette');
        ACAPI.OpenDistributionPalette();
      } else {
        AddLog('[UI] OpenDistributionPalette unavailable');
      }
    }
    function openOrientationPalette() {
      if (ACAPI?.OpenOrientationPalette) {
        AddLog('[UI] OpenOrientationPalette');
        ACAPI.OpenOrientationPalette();
      } else {
        AddLog('[UI] OpenOrientationPalette unavailable');
      }
    }
    function openGroundPalette() {
      if (ACAPI?.OpenGroundPalette) {
        AddLog('[UI] OpenGroundPalette');
        ACAPI.OpenGroundPalette();
      } else {
        AddLog('[UI] OpenGroundPalette unavailable');
      }
    }
    function openMarkupPalette() {
      if (ACAPI?.OpenMarkupPalette) {
        AddLog('[UI] OpenMarkupPalette');
        ACAPI.OpenMarkupPalette();
      } else {
        AddLog('[UI] OpenMarkupPalette unavailable');
      }
    }
    function openIdLayersPalette() {
      if (ACAPI?.OpenIdLayersPalette) {
        AddLog('[UI] OpenIdLayersPalette');
        ACAPI.OpenIdLayersPalette();
      } else {
        AddLog('[UI] OpenIdLayersPalette unavailable');
      }
    }
    function openAnglePalette() {
      if (ACAPI?.OpenAnglePalette) {
        AddLog('[UI] OpenAnglePalette');
        ACAPI.OpenAnglePalette();
      } else {
        AddLog('[UI] OpenAnglePalette unavailable');
      }
    }
    function openMeshPalette() {
      if (ACAPI?.OpenMeshPalette) {
        AddLog('[UI] OpenMeshPalette');
        ACAPI.OpenMeshPalette();
      } else {
        AddLog('[UI] OpenMeshPalette unavailable');
      }
    }
    function openContourPalette() {
      if (ACAPI?.OpenContourPalette) {
        AddLog('[UI] OpenContourPalette');
        ACAPI.OpenContourPalette();
      } else {
        AddLog('[UI] OpenContourPalette unavailable');
      }
    }
    
    // Orientation palette shortcuts
    function SetBeamsForOrient() { openAnglePalette(); }
    function SetMeshForBeams() { openAnglePalette(); }
    function OrientBeamsToSurface() { openAnglePalette(); }
    function RotateSelectedOrientation() { openAnglePalette(); }
    function SetDistributionStep () {
      const s = parseNumber(document.getElementById('distStep'), 0);
      const step = (isFinite(s) && s > 0) ? s : 0;
      if (ACAPI?.SetDistributionStep) ACAPI.SetDistributionStep(step);
      if (step > 0 && ACAPI?.DistributeNow) {
        const payload = "step:" + step;
        AddLog("[UI] Step OK ‚Üí " + payload);
        ACAPI.DistributeNow(payload).then(ok => setInfo("info-dist", ok ? "–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –ø–æ —à–∞–≥—É" : "–û—à–∏–±–∫–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è"));
      } else if (step <= 0) setInfo("info-dist", "–®–∞–≥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å > 0");
    }
    function SetDistributionCount () {
      const c = parseInt((document.getElementById('distCount').value || "0"), 10);
      const count = (isFinite(c) && c > 0) ? c : 0;
      if (ACAPI?.SetDistributionCount) ACAPI.SetDistributionCount(count);
      if (count > 0 && ACAPI?.DistributeNow) {
        const payload = "count:" + count;
        AddLog("[UI] Count OK ‚Üí " + payload);
        ACAPI.DistributeNow(payload).then(ok => setInfo("info-dist", ok ? "–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É" : "–û—à–∏–±–∫–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è"));
      } else if (count <= 0) setInfo("info-dist", "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å ‚â• 1");
    }

    // ================= SHELL / CONTOURS =================
    async function SetMeshForContours() { openContourPalette(); }
    function SelectBaseLine() { openContourPalette(); }
    function CreateShellFromLine() { openContourPalette(); }
    async function CreateMeshUI() { openContourPalette(); }

    // ================= MARKUP/DIMENSIONS =================

    // ================= MESH CREATION =================
    async function CreateMeshUI() { openContourPalette(); }

    // ================= MESH FROM LINE =================
    function SelectBaseLineMesh() { openMeshPalette(); }
    async function SetMeshForMesh() { openMeshPalette(); }
    async function CreateMeshFromLineUI() { openMeshPalette(); }

    function onShift(mm) {
      const m = parseFloat(mm) / 1000;
      AddLog(`[UI] Shift click, delta=${m} m`);
      if (window.ACAPI_Call) ACAPI_Call('ApplyZDelta', m);
    }
    function onLand() {
      AddLog(`[UI] Land click`);
      if (window.ACAPI_Call) ACAPI_Call('ApplyGroundOffset', 0.0);
    }

    // =============== tabs / init ===============
    function openTab(evt, tabId) {
      const contents = document.getElementsByClassName("tabcontent");
      const links = document.getElementsByClassName("tablink");
      for (let i = 0; i < contents.length; i++) contents[i].style.display = "none";
      for (let i = 0; i < links.length; i++) links[i].classList.remove("active");
      const tab = document.getElementById(tabId);
      if (tab) tab.style.display = "block";
      evt.currentTarget.classList.add("active");
      AddLog('[UI] Tab ‚Üí ' + tabId);
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å–ª–æ–µ–≤ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –≤–∫–ª–∞–¥–∫–∏ Layers
    }
    window.openTab = openTab;

    window.addEventListener('DOMContentLoaded', function () {
      AddLog("[UI] Ready (UI v0.4)");

      // Enter handlers
      document.getElementById('distStep')    ?.addEventListener('keydown', e => { if (e.key === 'Enter') SetDistributionStep(); });
      document.getElementById('distCount')   ?.addEventListener('keydown', e => { if (e.key === 'Enter') SetDistributionCount(); });

      // ID + Layers tab
      document.getElementById('baseID')      ?.addEventListener('keydown', e => { if (e.key === 'Enter') changeAllSelectedIDs(); });
      document.getElementById('layerFolder') ?.addEventListener('keydown', e => { if (e.key === 'Enter') createLayerAndMoveElements(); });
      document.getElementById('layerName')   ?.addEventListener('keydown', e => { if (e.key === 'Enter') createLayerAndMoveElements(); });
      
      // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ø–∏—Å–∫–∞ —Å–ª–æ–µ–≤ –ø—Ä–∏ –≤–≤–æ–¥–µ –≤ –ø–æ–ª–µ Layer Folder
      document.getElementById('layerFolder')?.addEventListener('input', function(e) {
        const filterText = e.target.value;
        if (!filterText.trim()) {
          expandedLayerFolders = new Set();
        }
        if (allLayersData.length > 0) {
          filterLayersList(filterText);
        }
      });
      
      // Markup
      document.getElementById('markupStep')  ?.addEventListener('keydown', e => { if (e.key === 'Enter') whenACAPIReadyDo(SetMarkupStepUI); });

      // help buttons
      document.addEventListener('click', function (e) {
        const el = e.target.closest('[data-help-url]');
        if (!el) return;
        e.preventDefault();
        let url = el.getAttribute('data-help-url') || 'https://landscape.227.info/help/start';
        const separator = url.includes('?') ? '&' : '?';
        const timestamp = Date.now();
        url = url + separator + 'v=' + timestamp;
        AddLog('[UI] help ‚Üí ' + url);

        const A = window.ACAPI;
        if (A && typeof A.OpenHelp === 'function') {
          Promise
            .resolve(A.OpenHelp(url))
            .then(() => AddLog('[UI] ACAPI.OpenHelp ok'))
            .catch(err => AddLog('[UI] ACAPI.OpenHelp error: ' + err));
        } else {
          AddLog('[UI] ACAPI.OpenHelp not found ‚Üí window.open');
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      });

      // wait for bridge, then fill selection table
      whenACAPIReadyDo(() => {
        UpdateSelectedElements();
      });

      // default tab: Distribution
      const defaultTab = document.querySelector('.tablink');
      if (defaultTab) defaultTab.click();
    });
  </script>
</head>

<body>
<div class="palette">
  <h1>–í—ã–±–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤</h1>

  <div class="section">
    <div class="section-title">–¢–µ–∫—É—â–∏–π –Ω–∞–±–æ—Ä</div>
    <div class="selection-table-container">
      <table class="selection-table">
        <thead>
          <tr>
            <th colspan="5">–í—ã–±—Ä–∞–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã</th>
          </tr>
          <tr>
            <th><input type="checkbox" id="select-all-checkbox" title="–í—ã–±—Ä–∞—Ç—å/—Å–Ω—è—Ç—å –≤—Å—ë" onchange="handleSelectAllCheckboxChange()"></th>
            <th>–¢–∏–ø</th>
            <th>ID</th>
            <th>–°–ª–æ–π</th>
            <th>–ö–æ–ª-–≤–æ</th>
          </tr>
        </thead>
        <tbody id="selection"><tr><td colspan="5">–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤</td></tr></tbody>
      </table>
      <div id="selection-info" class="info-box">–û—Ç–º–µ—Ç—å—Ç–µ –≥—Ä—É–ø–ø—ã —á–µ–∫–±–æ–∫—Å–∞–º–∏ –∏ –Ω–∞–∂–º–∏—Ç–µ OK, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å –≤ –≤—ã–¥–µ–ª–µ–Ω–∏–∏ —Ç–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –≥—Ä—É–ø–ø—ã.</div>
      <div class="controls-row">
        <button class="button-flat help-button" data-help-url="https://landscape.227.info/help/selection">–°–ø—Ä–∞–≤–∫–∞</button>
        <button id="selection-ok-btn" class="button-flat button-primary" onclick="applyCheckedSelection()">OK</button>
      </div>
    </div>
  </div>

  <div class="divider"></div>

  <div class="section">
    <div class="section-title">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</div>
    <div class="launcher-list">
      <button class="button-flat button-full" onclick="openDistributionPalette()">–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ</button>
      <button class="button-flat button-full" onclick="openOrientationPalette()">–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è</button>
      <button class="button-flat button-full" onclick="openAnglePalette()">–£–≥–æ–ª</button>
      <button class="button-flat button-full" onclick="openGroundPalette()">–ü—Ä–∏–≤—è–∑–∫–∞</button>
      <button class="button-flat button-full" onclick="openMarkupPalette()">–†–∞–∑–º–µ—Ç–∫–∞</button>
      <button class="button-flat button-full" onclick="openIdLayersPalette()">ID / –°–ª–æ–∏</button>
      <button class="button-flat button-full" onclick="openContourPalette()">–ö–æ–Ω—Ç—É—Ä—ã</button>
      <button class="button-flat button-full" onclick="openMeshPalette()">–°–µ—Ç–∫–∞</button>
    </div>
  </div>

  <div class="divider"></div>

    <div class="section">
    <div id="log-box" class="log-box">[–ó–¥–µ—Å—å –±—É–¥–µ—Ç –∂—É—Ä–Ω–∞–ª –ø–ª–∞–≥–∏–Ω–∞]</div>
  </div>

  <div class="link-minor">
    <a href="#"
       data-help-url="https://landscape.227.info/payment"
       data-help-title="Landscape Helper ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞">
      Landscape Helper
    </a>
  </div>
</div>
</body>
</html>


