<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Отправка в Excel</title>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #efefef;
      margin: 0;
      padding: 12px 0;
      color: #2f2f2f;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .palette {
      width: 500px;
      background: #efefef;
      border: 1px solid #a6a3a0;
      box-shadow: inset 0 0 0 1px #f8f8f8;
      padding: 12px;
      box-sizing: border-box;
      font-size: 12px;
      line-height: 1.35;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .section {
      margin-bottom: 12px;
    }
    .section-title {
      font-size: 11px;
      text-transform: uppercase;
      font-weight: 600;
      color: #4f4d4a;
      margin-bottom: 6px;
    }
    .section-subtitle {
      font-size: 11px;
      font-weight: 600;
      margin: 4px 0;
      color: #333;
    }
    .info-box {
      border: 1px solid #c0beb9;
      background: #f9f8f6;
      padding: 6px;
      font-size: 11px;
      margin-top: 8px;
      min-height: 32px;
      white-space: pre-wrap;
    }
    .table-wrapper {
      border: 1px solid #c7c3bd;
      background: #ffffff;
      max-height: 240px;
      overflow: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    th, td {
      padding: 4px 6px;
      border-bottom: 1px solid #e0ddd8;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #dedbd5;
      text-transform: uppercase;
      font-size: 10px;
      letter-spacing: 0.4px;
    }
    tr:nth-child(even) td {
      background: #f7f6f3;
    }
    .controls-row {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin: 6px 0;
    }
    .button-flat {
      padding: 4px 12px;
      border: 1px solid #a8a5a2;
      border-radius: 2px;
      background: #dcd9d4;
      color: #2f2f2f;
      font-size: 12px;
      cursor: pointer;
      box-shadow: inset 0 1px 0 #f5f4f2;
    }
    .button-flat:hover { background: #e7e4de; }
    .button-flat:active { background: #cac7c2; }
    .cell-checkbox {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .cell-checkbox input {
      margin: 0;
    }
    .row-checkbox-header,
    .row-checkbox-cell {
      width: 34px;
      text-align: center;
    }
    .row-checkbox-cell input,
    .column-checkbox,
    #select-all-cells {
      cursor: pointer;
    }
    .column-header {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
    }
    .chosen-section {
      margin-top: 16px;
    }
    .chosen-table-wrapper {
      border: 1px solid #c7c3bd;
      background: #ffffff;
      overflow-x: auto;
    }
    #chosen-table {
      min-width: 100%;
    }
    #chosen-placeholder {
      border: 1px dashed #b7b4ad;
      background: #fffdf9;
      padding: 10px;
      font-size: 11px;
      color: #6b6863;
    }
  </style>

  <script>
    "use strict";

    const FIELD_KEYS = ['type', 'id', 'layer', 'count', 'prop', 'seo'];
    const FIELD_LABELS = {
      type: 'Тип',
      id: 'ID',
      layer: 'Слой',
      count: 'Кол-во',
      prop: 'Свойство',
      seo: 'SEO'
    };

    let selectedCells = [];
    const selectedCellsMap = new Map();
    const mergeMasters = new Map(); // legacy, не используется в строковом режиме, оставлен на будущее
    const fieldOrder = [];
    const cellMeta = new Map(); // cellId -> { field, title, value, group }
    const sourceRowsByGuid = new Map(); // guid -> { type, elemID, layer }
    let capturedSelectionGuid = null;
    let capturedSelectionCount = 0;
    let activeElementGuid = null; // GUID элемента, выбранного пользователем как источник данных
    let lastSelectionElems = [];  // полное выделение Archicad (для повторного рендера)

    function setInfo(text) {
      const box = document.getElementById('selection-summary');
      if (box) {
        box.textContent = text;
      }
    }

    function whenACAPIReadyDo(cb) {
      if (typeof cb !== 'function') {
        return;
      }
      const ready = () => window.ACAPI && typeof window.ACAPI.GetSelectedElements === 'function';
      if (ready()) {
        cb();
        return;
      }
      let tries = 0;
      const maxTries = 200;
      const timer = setInterval(() => {
        if (ready()) {
          clearInterval(timer);
          cb();
        } else if (++tries > maxTries) {
          clearInterval(timer);
          setInfo('Не удалось подключиться к ACAPI. Откройте основную палитру и попробуйте снова.');
        }
      }, 100);
    }

    function groupSelection(elemInfos) {
      const map = new Map();
      if (!Array.isArray(elemInfos)) {
        return map;
      }
      for (let i = 0; i < elemInfos.length; i++) {
        const row = elemInfos[i] || [];
        const guid = typeof row[0] === 'string' ? row[0] : '';
        const type = String(row[1] || '—');
        const elemID = String(row[2] || '—');
        const layer = String(row[3] || '—');
        const key = type + '\u0001' + elemID + '\u0001' + layer;
        if (!map.has(key)) {
          map.set(key, { type, elemID, layer, count: 0, guid });
        }
        const group = map.get(key);
        group.count += 1;
        if (!group.guid && guid) {
          group.guid = guid;
        }
      }
      return map;
    }

    function refreshSelection() {
      const A = window.ACAPI;
      if (!A || typeof A.GetSelectedElements !== 'function') {
        setInfo('ACAPI.GetSelectedElements недоступна.');
        capturedSelectionGuid = null;
        capturedSelectionCount = 0;
        clearAllSelections();
        updateActionButtonsState();
        return;
      }
      setInfo('Загрузка выделения...');
      A.GetSelectedElements()
        .then(data => {
          clearAllSelections();
          renderSelection(Array.isArray(data) ? data : []);
        })
        .catch(err => {
          setInfo('Ошибка получения выделения: ' + err);
          capturedSelectionGuid = null;
          capturedSelectionCount = 0;
          clearAllSelections();
          updateActionButtonsState();
        });
    }

    function renderSelection(elemInfos) {
      lastSelectionElems = Array.isArray(elemInfos) ? elemInfos.slice() : [];
      const snapshot = captureSelectionSnapshot(elemInfos);
      applySelectionSnapshot(snapshot);

      const tbody = document.getElementById('selection-body');
      if (!tbody) {
        return;
      }
      cellMeta.clear();

      const groups = groupSelection(elemInfos);
      const rows = [];

      // Обновляем список источников для расчета (верхний блок)
      renderSourceTable(groups);

      if (groups.size === 0) {
        rows.push('<tr><td colspan="6">Нет выбранных элементов</td></tr>');
      } else {
        const sorted = Array.from(groups.values()).sort((a, b) => {
          return (a.type.localeCompare(b.type, 'ru')) ||
                 (a.elemID.localeCompare(b.elemID, 'ru')) ||
                 (a.layer.localeCompare(b.layer, 'ru'));
        });

        const displayRows = sorted.filter(group => {
          if (!activeElementGuid || !group.guid) {
            return !activeElementGuid; // если источник не выбран, показываем все
          }
          return group.guid === activeElementGuid;
        });

        (displayRows.length > 0 ? displayRows : sorted).forEach(group => {
          const groupKey = [group.type, group.elemID || '—', group.layer || '—'].join('||');
          const typeCell = buildSelectableCell(groupKey, 'type', group.type);
          const idCell = buildSelectableCell(groupKey, 'id', group.elemID || '—');
          const layerCell = buildSelectableCell(groupKey, 'layer', group.layer || '—');
          const countCell = buildSelectableCell(groupKey, 'count', String(group.count));

          const sourceCell =
            '<td class="row-checkbox-cell"></td>';

          const rowCheckbox =
            '<td class="row-checkbox-cell">' +
            '<input type="checkbox" class="row-checkbox" ' +
            'data-group="' + escapeAttr(groupKey) + '" ' +
            'data-type="' + escapeAttr(group.type) + '" ' +
            'data-id="' + escapeAttr(group.elemID || "—") + '" ' +
            'data-layer="' + escapeAttr(group.layer || "—") + '" ' +
            'data-count="' + String(group.count) + '" ' +
            'title="Выбрать строку для таблицы ниже">' +
            '</td>';

          rows.push(
            '<tr>' +
            sourceCell +
            rowCheckbox +
            typeCell.html +
            idCell.html +
            layerCell.html +
            countCell.html +
            '</tr>'
          );
        });
      }

      tbody.innerHTML = rows.join('');
      renderChosenTable();
    }

    function captureSelectionSnapshot(elemInfos) {
      const snapshot = {
        totalCount: Array.isArray(elemInfos) ? elemInfos.length : 0,
        firstGuid: null
      };
      if (Array.isArray(elemInfos)) {
        for (const row of elemInfos) {
          const guid = extractGuidFromRow(row);
          if (guid) {
            snapshot.firstGuid = guid;
            break;
          }
        }
      }
      return snapshot;
    }

    function extractGuidFromRow(row) {
      if (!Array.isArray(row)) {
        return null;
      }
      const guidCandidate = row[0];
      if (typeof guidCandidate === 'string' && guidCandidate.length > 0) {
        return guidCandidate;
      }
      return null;
    }

    function applySelectionSnapshot(snapshot) {
      capturedSelectionGuid = snapshot.firstGuid;
      capturedSelectionCount = snapshot.totalCount;

      // Если источник ещё не выбран, по умолчанию берём первый GUID из снимка
      updateActionButtonsState();

      if (!snapshot.totalCount || !snapshot.firstGuid) {
        setInfo('Нет выбранных элементов. Нажмите «Обновить», чтобы зафиксировать выделение.');
        return;
      }
      setInfo('Снимок выделения: элементов ' + snapshot.totalCount);
    }

    function buildSelectableCell(groupKey, field, value) {
      const cellId = groupKey + '::' + field;
      const displayValue = value === undefined || value === null || value === '' ? '—' : String(value);
      const html = '<td>' + escapeHtml(displayValue) + '</td>';
      return { id: cellId, html };
    }

    function addSelectedCell(entry) {
      if (selectedCellsMap.has(entry.id)) {
        return;
      }
      selectedCells.push(entry);
      selectedCellsMap.set(entry.id, entry);
      if (!fieldOrder.includes(entry.field)) {
        fieldOrder.push(entry.field);
      }
    }

    function removeSelectedCell(id) {
      const entry = selectedCellsMap.get(id);
      if (!entry) {
        return;
      }
      selectedCellsMap.delete(id);
      selectedCells = selectedCells.filter(item => item.id !== id);
      if (!selectedCells.some(item => item.field === entry.field)) {
        const idx = fieldOrder.indexOf(entry.field);
        if (idx >= 0) {
          fieldOrder.splice(idx, 1);
        }
      }
    }

    function clearAllSelections() {
      // Сбрасываем все выбранные строки и соответствующие галочки
      selectedCells = [];
      selectedCellsMap.clear();
      fieldOrder.length = 0;

      document.querySelectorAll('.row-checkbox, .prop-checkbox, .metrics-row-checkbox').forEach(cb => {
        cb.checked = false;
      });

      renderChosenTable();
    }

    function pruneStaleSelections(validIds) {
      let changed = false;
      selectedCells = selectedCells.filter(entry => {
        const keep = validIds.has(entry.id);
        if (!keep) {
          selectedCellsMap.delete(entry.id);
          changed = true;
        }
        return keep;
      });
      if (changed) {
        for (let i = fieldOrder.length - 1; i >= 0; i--) {
          if (!selectedCells.some(cell => cell.field === fieldOrder[i])) {
            fieldOrder.splice(i, 1);
          }
        }
      }
    }

    function applySelectionToCell(cellId, shouldSelect) {
      const meta = cellMeta.get(cellId);
      if (!meta) {
        return;
      }
      if (shouldSelect) {
        addSelectedCell({ id: cellId, field: meta.field, title: meta.title, value: meta.value });
      } else {
        removeSelectedCell(cellId);
      }
      const checkbox = Array.from(document.querySelectorAll('.cell-checkbox-input'))
        .find(cb => cb.dataset.cellId === cellId);
      if (checkbox) {
        checkbox.checked = shouldSelect;
      }
    }

    function renderSourceTable(groups) {
      sourceRowsByGuid.clear();
      const tbody = document.getElementById('source-body');
      if (!tbody) {
        return;
      }

      if (!groups || groups.size === 0) {
        tbody.innerHTML = '<tr><td colspan="4">Нет выбранных элементов</td></tr>';
        activeElementGuid = null;
        updateActiveElementInfo();
        updateActionButtonsState();
        return;
      }

      const sorted = Array.from(groups.values()).sort((a, b) => {
        return (a.type.localeCompare(b.type, 'ru')) ||
               (a.elemID.localeCompare(b.elemID, 'ru')) ||
               (a.layer.localeCompare(b.layer, 'ru'));
      });

      let rowsHtml = '';
      let firstGuid = null;

      sorted.forEach(group => {
        const guid = group.guid || '';
        if (guid) {
          sourceRowsByGuid.set(guid, {
            type: group.type,
            elemID: group.elemID || '—',
            layer: group.layer || '—'
          });
          if (!firstGuid) {
            firstGuid = guid;
          }
        }

        const isChecked = guid && guid === activeElementGuid;
        rowsHtml += '<tr>' +
          '<td style="width:32px;text-align:center;">' +
            (guid
              ? '<input type="radio" class="source-radio" name="source-element" ' +
                'data-guid="' + escapeAttr(guid) + '" ' +
                (isChecked ? 'checked' : '') +
                ' title="Использовать этот элемент для свойств и SEO">'
              : '') +
          '</td>' +
          '<td>' + escapeHtml(group.type) + '</td>' +
          '<td>' + escapeHtml(group.elemID || '—') + '</td>' +
          '<td>' + escapeHtml(group.layer || '—') + '</td>' +
        '</tr>';
      });

      // Если источник ещё не выбран, используем первый доступный GUID
      if (!activeElementGuid && firstGuid) {
        activeElementGuid = firstGuid;
      }

      tbody.innerHTML = rowsHtml;
      updateActiveElementInfo();
      updateActionButtonsState();
    }

    function updateActiveElementInfo() {
      const typeCell = document.getElementById('info-type');
      const idCell = document.getElementById('info-id');
      const layerCell = document.getElementById('info-layer');

      if (!activeElementGuid || !sourceRowsByGuid.has(activeElementGuid)) {
        if (typeCell) typeCell.textContent = '—';
        if (idCell) idCell.textContent = '—';
        if (layerCell) layerCell.textContent = '—';
        setInfo('Нет выбранного элемента для расчета. Нажмите «Обновить» и выберите строку.');
        return;
      }

      const info = sourceRowsByGuid.get(activeElementGuid);
      if (typeCell) typeCell.textContent = info.type || '—';
      if (idCell) idCell.textContent = info.elemID || '—';
      if (layerCell) layerCell.textContent = info.layer || '—';

      const summary = 'Элементов в выделении: ' + (capturedSelectionCount || 0) +
        '. Элемент для расчета: ' + info.type + ' / ' + (info.elemID || '—') + ' / ' + (info.layer || '—');
      setInfo(summary);
    }

    function toggleRowSelection(rowCheckbox) {
      const shouldSelect = rowCheckbox.checked;
      const type = rowCheckbox.dataset.type || '—';
      const id = rowCheckbox.dataset.id || '—';
      const layer = rowCheckbox.dataset.layer || '—';
      const count = rowCheckbox.dataset.count || '';
      const groupKey = rowCheckbox.dataset.group || [type, id, layer].join('||');
      const baseId = 'sel::' + groupKey;
      const ids = [
        baseId + '::source',
        baseId + '::type',
        baseId + '::id',
        baseId + '::layer',
        baseId + '::count'
      ];

      if (shouldSelect) {
        addSelectedCell({
          id: ids[0],
          field: 'selection',
          title: 'Источник',
          value: 'Выделение Archicad'
        });
        addSelectedCell({
          id: ids[1],
          field: 'selection',
          title: 'Тип',
          value: type
        });
        addSelectedCell({
          id: ids[2],
          field: 'selection',
          title: 'ID',
          value: id
        });
        addSelectedCell({
          id: ids[3],
          field: 'selection',
          title: 'Слой',
          value: layer
        });
        addSelectedCell({
          id: ids[4],
          field: 'selection',
          title: 'Кол-во',
          value: String(count)
        });
      } else {
        ids.forEach(idVal => removeSelectedCell(idVal));
      }
      renderChosenTable();
    }

    function updateActionButtonsState() {
      const hasGuid = typeof activeElementGuid === 'string' && activeElementGuid.length > 0;
      const propsBtn = document.getElementById('props-refresh-btn');
      const metricsBtn = document.getElementById('metrics-refresh-btn');
      if (propsBtn) {
        propsBtn.disabled = !hasGuid;
      }
      if (metricsBtn) {
        metricsBtn.disabled = !hasGuid;
      }
    }

    function updateRowCheckboxes() {}

    function updateColumnCheckboxes() {}

    function updateMasterCheckbox() {}

    function renderChosenTable() {
      const table = document.getElementById('chosen-table');
      const placeholder = document.getElementById('chosen-placeholder');
      const headerRow = document.getElementById('chosen-title-row');
      const body = document.getElementById('chosen-body');

      if (!table || !placeholder || !body || !headerRow) {
        return;
      }

      if (!selectedCells || selectedCells.length === 0) {
        table.style.display = 'none';
        placeholder.style.display = 'block';
        headerRow.innerHTML = '';
        body.innerHTML = '';
        return;
      }

      // Таблица 5‑ти столбцовая:
      //   - фиксированная шапка из 5 колонок
      //   - каждая выбранная СТРОКА из любой таблицы = отдельная строка здесь
      const columnsCount = 5;
      headerRow.innerHTML =
        '<th>Источник</th>' +
        '<th>Поле 1</th>' +
        '<th>Поле 2</th>' +
        '<th>Поле 3</th>' +
        '<th>Поле 4</th>';

      // Группируем выбранные значения по строкам (по префиксу id до последнего "::")
      const rowMap = new Map();   // rowId -> Array<entry>
      const rowOrder = [];        // порядок появления строк

      selectedCells.forEach(entry => {
        const id = entry.id || '';
        const lastIdx = id.lastIndexOf('::');
        const rowId = lastIdx > 0 ? id.slice(0, lastIdx) : id;
        if (!rowMap.has(rowId)) {
          rowMap.set(rowId, []);
          rowOrder.push(rowId);
        }
        rowMap.get(rowId).push(entry);
      });

      const rows = [];
      rowOrder.forEach(rowId => {
        const entries = rowMap.get(rowId) || [];
        const cells = new Array(columnsCount).fill('');

        let idx = 0;
        entries.forEach(e => {
          if (idx < columnsCount) {
            cells[idx++] = e.value || '';
          }
        });

        const cellsHtml = cells.map(v => '<td>' + escapeHtml(v) + '</td>');
        rows.push('<tr>' + cellsHtml.join('') + '</tr>');
      });

      body.innerHTML = rows.join('');
      table.style.display = 'table';
      placeholder.style.display = 'none';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function escapeAttr(text) {
      return String(text)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/'/g, '&#39;');
    }

    async function loadSelectedProperties() {
      const guid = activeElementGuid;
      if (!guid) {
        setPropertyInfoMessage('Не выбран элемент-источник. Отметьте строку в таблице выше.');
        renderPropertyTable([]);
        return;
      }
      if (!window.ACAPI || typeof window.ACAPI.GetSelectedProperties !== 'function') {
        setPropertyInfoMessage('Функция получения свойств недоступна в этой версии.');
        return;
      }
      setPropertyInfoMessage('Загрузка свойств...');
      try {
        const props = await window.ACAPI.GetSelectedProperties(guid);
        renderPropertyTable(Array.isArray(props) ? props : []);
        setPropertyInfoMessage(props && props.length > 0
          ? `Получено ${props.length} свойств`
          : 'Свойства не найдены. Выберите элемент и попробуйте снова.');
      } catch (error) {
        setPropertyInfoMessage('Ошибка: ' + error);
        renderPropertyTable([]);
      }
    }

    function renderPropertyTable(props) {
      const body = document.getElementById('property-body');
      if (!body) {
        return;
      }
      if (!props || props.length === 0) {
        body.innerHTML = '<tr><td colspan="3">Нет данных для отображения</td></tr>';
        return;
      }
      const rows = props.map(prop => {
        const guid = typeof prop.guid === 'string' ? prop.guid : '';
        const name = typeof prop.name === 'string' ? prop.name : '';
        const value = typeof prop.value === 'string' ? prop.value : '';
        return '<tr>' +
          '<td><input type="checkbox" class="prop-checkbox" ' +
          'data-guid="' + escapeAttr(guid) + '" ' +
          'data-name="' + escapeAttr(name) + '" ' +
          'data-value="' + escapeAttr(value) + '"></td>' +
          '<td>' + escapeHtml(name) + '</td>' +
          '<td>' + escapeHtml(value) + '</td>' +
        '</tr>';
      });
      body.innerHTML = rows.join('');
    }

    function setPropertyInfoMessage(message) {
      const box = document.getElementById('property-info');
      if (box) {
        box.textContent = message;
      }
    }

    async function loadSeoMetrics() {
      const guid = capturedSelectionGuid;
      if (!guid) {
        setMetricsInfoMessage('Нет снимка выделения. Нажмите «Обновить» выше.');
        renderSeoMetricsTable([]);
        return;
      }
      if (!window.ACAPI || typeof window.ACAPI.GetSelectionSeoMetrics !== 'function') {
        setMetricsInfoMessage('Функция расчета метрик недоступна.');
        renderSeoMetricsTable([]);
        return;
      }
      setMetricsInfoMessage('Расчет площадей и объемов...');
      try {
        const metrics = await window.ACAPI.GetSelectionSeoMetrics(guid);
        renderSeoMetricsTable(Array.isArray(metrics) ? metrics : []);
        setMetricsInfoMessage(metrics && metrics.length
          ? `Получено метрик: ${metrics.length}`
          : 'Нет доступных метрик для выделенного элемента.');
      } catch (err) {
        setMetricsInfoMessage('Ошибка: ' + err);
        renderSeoMetricsTable([]);
      }
    }

    function renderSeoMetricsTable(metrics) {
      const body = document.getElementById('metrics-body');
      if (!body) {
        return;
      }
      if (!metrics || metrics.length === 0) {
        body.innerHTML = '<tr><td colspan="5">Нет данных для отображения</td></tr>';
        return;
      }
      const rows = metrics.map(metric => {
        const name = typeof metric.name === 'string' ? metric.name : '—';
        const gross = formatNumber(metric.grossValue);
        const net = formatNumber(metric.netValue);
        const diff = formatNumber(metric.diffValue);
        return '<tr>' +
          '<td class="row-checkbox-cell">' +
            '<input type="checkbox" class="metrics-row-checkbox" title="Выбрать строку">' +
          '</td>' +
          '<td class="metrics-name-cell">' + escapeHtml(name) + '</td>' +
          '<td class="metrics-gross-cell">' + gross + '</td>' +
          '<td class="metrics-net-cell">' + net + '</td>' +
          '<td class="metrics-diff-cell">' + diff + '</td>' +
        '</tr>';
      });
      body.innerHTML = rows.join('');
    }

    function handleMetricsRowSelection(row, isChecked) {
      if (!row) {
        return;
      }
      const nameCell = row.querySelector('.metrics-name-cell');
      const grossCell = row.querySelector('.metrics-gross-cell');
      const netCell = row.querySelector('.metrics-net-cell');
      const diffCell = row.querySelector('.metrics-diff-cell');

      const metricName = nameCell ? nameCell.textContent.trim() : '';
      const gross = grossCell ? grossCell.textContent.trim() : '';
      const net = netCell ? netCell.textContent.trim() : '';
      const diff = diffCell ? diffCell.textContent.trim() : '';

      // Для каждой строки SEO добавляем 5 ячеек:
      // 1) Источник данных (SEO)
      // 2) Название показателя
      // 3) Значение "Без SEO"
      // 4) Значение "С SEO"
      // 5) |Δ|
      const baseId = 'metric::seo::' + metricName;
      const ids = [
        baseId + '::source',
        baseId + '::name',
        baseId + '::gross',
        baseId + '::net',
        baseId + '::diff'
      ];

      if (isChecked) {
        addSelectedCell({
          id: ids[0],
          field: 'seo',
          title: 'Источник',
          value: 'SEO'
        });
        addSelectedCell({
          id: ids[1],
          field: 'seo',
          title: 'Показатель',
          value: metricName
        });
        addSelectedCell({
          id: ids[2],
          field: 'seo',
          title: 'Без SEO',
          value: gross
        });
        addSelectedCell({
          id: ids[3],
          field: 'seo',
          title: 'С SEO',
          value: net
        });
        addSelectedCell({
          id: ids[4],
          field: 'seo',
          title: '|Δ|',
          value: diff
        });
      } else {
        ids.forEach(id => removeSelectedCell(id));
      }
      renderChosenTable();
    }

    function formatNumber(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return '—';
      }
      return value.toLocaleString('ru-RU', {
        minimumFractionDigits: 3,
        maximumFractionDigits: 3
      });
    }

    function setMetricsInfoMessage(message) {
      const box = document.getElementById('metrics-info');
      if (box) {
        box.textContent = message;
      }
    }

    function buildCsvFromChosenTable() {
      const rows = [];
      const body = document.getElementById('chosen-body');
      const header = document.getElementById('chosen-title-row');
      if (!body || !header) {
        return '';
      }

      const sep = ';';

      const headerCells = Array.from(header.querySelectorAll('th')).map(th => th.textContent.trim());
      if (headerCells.length > 0) {
        rows.push(headerCells.map(v => escapeCsv(v, sep)).join(sep));
      }

      Array.from(body.querySelectorAll('tr')).forEach(tr => {
        const cells = Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim());
        rows.push(cells.map(v => escapeCsv(v, sep)).join(sep));
      });

      return rows.join('\r\n');
    }

    function escapeCsv(value, sep) {
      const needsQuote = value.includes(sep) || value.includes('"') || value.includes('\n') || value.includes('\r');
      let v = value.replace(/"/g, '""');
      return needsQuote ? '"' + v + '"' : v;
    }

    async function exportChosenToCsv() {
      if (!window.ACAPI || typeof window.ACAPI.SaveSendXls !== 'function') {
        alert('Функция выгрузки недоступна в этой версии надстройки.');
        return;
      }
      const csv = buildCsvFromChosenTable();
      if (!csv) {
        alert('Нет выбранных данных для выгрузки.');
        return;
      }
      try {
        const ok = await window.ACAPI.SaveSendXls(csv);
        if (!ok) {
          // пользователь мог просто отменить диалог сохранения — без сообщений
          return;
        }
      } catch (e) {
        alert('Ошибка при сохранении CSV: ' + e);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.column-checkbox').forEach(cb => cb.disabled = true);
      updateActionButtonsState();

      const refreshBtn = document.getElementById('refresh-btn');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => whenACAPIReadyDo(refreshSelection));
      }

      const refreshLegacyBtn = document.getElementById('refresh-btn-legacy');
      if (refreshLegacyBtn) {
        refreshLegacyBtn.addEventListener('click', () => whenACAPIReadyDo(refreshSelection));
      }

      const propsBtn = document.getElementById('props-refresh-btn');
      if (propsBtn) {
        propsBtn.addEventListener('click', () => whenACAPIReadyDo(loadSelectedProperties));
      }

      const metricsBtn = document.getElementById('metrics-refresh-btn');
      if (metricsBtn) {
        metricsBtn.addEventListener('click', () => whenACAPIReadyDo(loadSeoMetrics));
      }

      const exportBtn = document.getElementById('export-btn');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => whenACAPIReadyDo(exportChosenToCsv));
      }

      whenACAPIReadyDo(() => {
        refreshSelection();
      });
      window.addEventListener('focus', () => {
        whenACAPIReadyDo(refreshSelection);
      });
    });

    document.addEventListener('change', event => {
      const target = event.target;
      if (target.classList.contains('cell-checkbox-input')) {
        applySelectionToCell(target.dataset.cellId, target.checked);
        updateSelectionControls();
        renderChosenTable();
      } else if (target.classList.contains('prop-checkbox')) {
        const guid = target.dataset.guid || '';
        const name = target.dataset.name || '';
        const value = target.dataset.value || '';
        if (target.checked) {
          // добавляем отдельные ячейки: источник, имя, значение
          const baseId = 'prop::' + guid + '::' + name;
          const ids = [
            baseId + '::source',
            baseId + '::name',
            baseId + '::value'
          ];
          addSelectedCell({
            id: ids[0],
            field: 'prop',
            title: 'Источник',
            value: 'Свойство выделенного элемента'
          });
          addSelectedCell({
            id: ids[1],
            field: 'prop',
            title: 'Свойство',
            value: name
          });
          addSelectedCell({
            id: ids[2],
            field: 'prop',
            title: 'Значение',
            value: value
          });
        } else {
          const baseId = 'prop::' + guid + '::' + name;
          ['::source', '::name', '::value'].forEach(suffix => {
            removeSelectedCell(baseId + suffix);
          });
        }
        renderChosenTable();
      } else if (target.classList.contains('source-radio')) {
        activeElementGuid = target.dataset.guid || null;
        updateActionButtonsState();
        // перерассчитываем таблицу "Выделение Archicad (для выгрузки)" только для выбранного источника
        if (lastSelectionElems.length > 0) {
          renderSelection(lastSelectionElems);
        }
      } else if (target.id === 'metrics-select-all') {
        const rows = Array.from(document.querySelectorAll('.metrics-row-checkbox'));
        rows.forEach(cb => {
          cb.checked = target.checked;
          handleMetricsRowSelection(cb.closest('tr'), cb.checked);
        });
      } else if (target.classList.contains('metrics-row-checkbox')) {
        const row = target.closest('tr');
        if (!row) return;
        handleMetricsRowSelection(row, target.checked);
      } else if (target.classList.contains('row-checkbox')) {
        toggleRowSelection(target);
      } else if (target.classList.contains('column-checkbox')) {
        // больше не используется
      } else if (target.classList.contains('merge-radio-input')) {
        const label = target.dataset.label;
        const field = target.value;
        mergeMasters.set(label, field);
        renderChosenTable();
      }
    });
  </script>
</head>

<body>
  <div class="palette">
    <h1>Отправка в Excel</h1>

    <!-- Блок 1: Что считаем -->
    <div class="section">
      <div class="section-title">Элемент для расчета</div>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th>Тип</th>
              <th>ID</th>
              <th>Слой</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td id="info-type">—</td>
              <td id="info-id">—</td>
              <td id="info-layer">—</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div id="selection-summary" class="info-box">
        Ожидание данных Archicad...
      </div>
      <div class="section-subtitle">Что именно считать</div>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th style="width:32px;">Источник</th>
              <th>Тип</th>
              <th>ID</th>
              <th>Слой</th>
            </tr>
          </thead>
          <tbody id="source-body">
            <tr><td colspan="4">Нет выбранных элементов</td></tr>
          </tbody>
        </table>
      </div>
      <div class="controls-row">
        <button id="refresh-btn" class="button-flat">Обновить</button>
      </div>
    </div>

    <!-- Блок 2: Таблица выбора (как раньше, но ниже) -->
    <div class="section">
      <div class="section-title">Выделение Archicad (для выгрузки)</div>
      <div class="controls-row">
        <button id="refresh-btn-legacy" class="button-flat">Обновить таблицу</button>
      </div>
      <div class="table-wrapper selection-table">
        <table>
          <thead>
            <tr>
              <th class="row-checkbox-header">Источник</th>
              <th class="row-checkbox-header">Выбор</th>
              <th>Тип</th>
              <th>ID</th>
              <th>Слой</th>
              <th>Кол-во</th>
            </tr>
          </thead>
          <tbody id="selection-body">
            <tr><td colspan="6">Загрузка...</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Свойства выделенного элемента</div>
      <div class="controls-row">
        <button id="props-refresh-btn" class="button-flat">Обновить свойства</button>
      </div>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th>Выгрузка</th>
              <th>Название</th>
              <th>Значение</th>
            </tr>
          </thead>
          <tbody id="property-body">
            <tr><td colspan="3">Нет данных для отображения</td></tr>
          </tbody>
        </table>
      </div>
      <div id="property-info" class="info-box">Нажмите «Обновить» выше, чтобы зафиксировать выделение, затем «Обновить свойства».</div>
    </div>

    <div class="section">
      <div class="section-title">Площади и объемы (SEO)</div>
      <div class="controls-row">
        <button id="metrics-refresh-btn" class="button-flat">Пересчитать</button>
      </div>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th class="row-checkbox-header">
                <input type="checkbox" id="metrics-select-all" title="Выбрать все">
              </th>
              <th>Показатель</th>
              <th>Без SEO</th>
              <th>С SEO</th>
              <th>|Δ|</th>
            </tr>
          </thead>
          <tbody id="metrics-body">
            <tr><td colspan="5">Нет данных для отображения</td></tr>
          </tbody>
        </table>
      </div>
      <div id="metrics-info" class="info-box">Нажмите «Обновить», затем «Пересчитать», чтобы сравнить значения до и после SEO.</div>
    </div>

    <!-- Блок: выбранные данные (порядок выгрузки) -->
    <div class="section chosen-section">
      <div class="section-title">Выбранные данные (порядок выгрузки)</div>
      <div class="chosen-table-wrapper">
        <table id="chosen-table" style="display:none;">
          <thead>
            <tr id="chosen-title-row"></tr>
          </thead>
          <tbody id="chosen-body"></tbody>
        </table>
      </div>
      <div id="chosen-placeholder">
        Выберите строки в таблицах выше — каждая выбранная строка появится здесь отдельной строкой в таблице из 5-ти столбцов.
      </div>
    </div>

    <!-- Нижний блок: кнопки -->
    <div class="section">
      <div class="controls-row" style="justify-content: space-between;">
        <button id="help-btn" class="button-flat">Справка</button>
        <button id="export-btn" class="button-flat">Выгрузка</button>
      </div>
    </div>
  </div>
</body>
</html>

